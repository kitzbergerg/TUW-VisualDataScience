<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geopolitical Relations Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #64748b;
            --accent: #3b82f6;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-color);
            margin: 0;
            padding: 20px;
            color: var(--text-primary);
        }

        .dashboard-container {
            max-width: 1600px;
            margin: 0 auto;
        }

        /* --- Header & Controls --- */
        header {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        select, input[type="number"] {
            padding: 6px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: #fff;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 150px;
            accent-color: var(--accent);
        }

        /* --- Main Grid Layout --- */
        .viz-grid {
            display: grid;
            grid-template-columns: 2fr 1fr; /* Map takes 2/3, Bar Chart 1/3 */
            grid-template-rows: auto auto;
            gap: 20px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Specific Areas */
        .area-map {
            grid-column: 1 / 2;
            grid-row: 1;
            min-height: 500px;
        }

        .area-ranking {
            grid-column: 2 / 3;
            grid-row: 1;
        }

        .area-scatter {
            grid-column: 1 / 2;
            grid-row: 2;
            height: 350px;
        }

        .area-timeline {
            grid-column: 2 / 3;
            grid-row: 2;
            height: 350px;
        }

        h2 {
            font-size: 1rem;
            color: var(--text-secondary);
            margin: 0 0 15px 0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* --- Visualization Specifics --- */
        .chart-container {
            flex-grow: 1;
            width: 100%;
            height: 100%; /* Fill the card */
            position: relative;
            overflow: hidden;
        }

        /* Map Legend */
        .map-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
        }

        .legend-bar {
            width: 160px;
            height: 12px;
            border-radius: 6px;
            /* This gradient mimics the d3.interpolateRdYlBu scale */
            background: linear-gradient(to right, #a50026, #d73027, #f46d43, #fdae61, #fee090, #e0f3f8, #abd9e9, #74add1, #4575b4, #313695);
            margin: 5px 0;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            line-height: 1.4;
        }

        /* Loading Overlay */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-size: 1.2rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        @media (max-width: 1024px) {
            .viz-grid {
                grid-template-columns: 1fr; /* Stack everything on tablet/mobile */
            }

            .area-map, .area-ranking, .area-scatter, .area-timeline {
                grid-column: auto;
                grid-row: auto;
            }

            .area-map {
                height: 400px;
            }
        }
    </style>
</head>
<body>

<div id="loading">Loading Data...</div>
<div id="tooltip"></div>

<div class="dashboard-container">
    <header>
        <h1>Global Geopolitical Relations Dashboard</h1>
        <div class="controls">
            <div class="control-group">
                <label for="yearSlider">Year:</label>
                <input type="range" id="yearSlider" min="2010" max="2025" value="2025" step="1">
                <strong id="yearLabel" style="min-width: 40px;">2025</strong>
            </div>
            <div class="control-group">
                <label for="countrySelect">Focus Country:</label>
                <select id="countrySelect">
                    <option value="UKR">Loading...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="metricSelect">Metric:</label>
                <select id="metricSelect">
                    <option value="AvgGoldstein">Goldstein Scale</option>
                    <option value="AvgTone">Avg Tone</option>
                </select>
            </div>
            <div class="control-group">
                <label for="minEvents">Min Events:</label>
                <input type="number" id="minEvents" value="1000" step="1000" min="0">
            </div>
        </div>
    </header>

    <div class="viz-grid">
        <div class="card area-map">
            <h2>Global Relations Map</h2>
            <div id="map" class="chart-container"></div>
            <div class="map-legend">
                <div class="legend-labels">
                    <span>Negative (-10)</span>
                    <span>Positive (+10)</span>
                </div>
                <div class="legend-bar"></div>
            </div>
        </div>

        <div class="card area-ranking">
            <h2>Top & Bottom Relations</h2>
            <div id="ranking" class="chart-container"></div>
        </div>

        <div class="card area-scatter">
            <h2>Tone vs. Event Volume</h2>
            <div id="scatter" class="chart-container"></div>
        </div>

        <div class="card area-timeline">
            <h2>Metric Over Time</h2>
            <div id="timeline" class="chart-container"></div>
        </div>
    </div>
</div>

<script>
    /**
     * Dashboard Application
     * Encapsulates state and logic to prevent global pollution
     */
    class Dashboard {
        constructor() {
            this.state = {
                currentYear: 2025,
                currentMetric: 'AvgGoldstein',
                currentCountry: 'UKR',
                minEvents: 1000
            };

            this.data = [];
            this.geoData = null;

            // Shared styling config
            this.config = {
                colors: {
                    highlight: '#3b82f6',
                    positive: '#4575b4',
                    negative: '#d73027',
                    neutral: '#fee090',
                    selectedStroke: '#1e293b'
                },
                margins: {top: 20, right: 20, bottom: 40, left: 50},
                transition: 400 // ms
            };

            // D3 Color Scale (Reversed: Red=Low, Blue=High)
            this.colorScale = d3.scaleSequential(d3.interpolateRdYlBu).domain([10, -10]);

            this.bindEvents();
        }

        async init() {
            try {
                // Parallel data loading
                const [geoData, csvData] = await Promise.all([
                    d3.json('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson'),
                    d3.csv('https://raw.githubusercontent.com/kitzbergerg/TUW-VisualDataScience/refs/heads/main/data/relations_2010_to_2025_sym.csv', d => ({
                        EventYear: +d.EventYear,
                        Country1: d.Country1,
                        Country2: d.Country2,
                        AvgGoldstein: +d.AvgGoldstein,
                        AvgTone: +d.AvgTone,
                        EventCount: +d.EventCount
                    }))
                ]);

                this.geoData = geoData;
                this.data = csvData;

                this.populateDropdown();
                this.update();

                d3.select('#loading').style('display', 'none');

            } catch (error) {
                console.error("Initialization Failed:", error);
                d3.select('#loading').text('Error loading data. Check console.');
            }
        }

        bindEvents() {
            // Slider
            d3.select('#yearSlider').on('input', (e) => {
                this.state.currentYear = +e.target.value;
                d3.select('#yearLabel').text(this.state.currentYear);
                this.update();
            });

            // Inputs
            d3.select('#metricSelect').on('change', (e) => {
                this.state.currentMetric = e.target.value;
                this.update();
            });

            d3.select('#countrySelect').on('change', (e) => {
                this.state.currentCountry = e.target.value;
                this.update();
            });

            d3.select('#minEvents').on('change', (e) => {
                this.state.minEvents = +e.target.value;
                this.update();
            });

            // Responsive resize
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => this.update(), 200);
            });
        }

        populateDropdown() {
            const countries = [...new Set(this.data.map(d => d.Country1))].sort();
            const select = d3.select('#countrySelect');
            select.selectAll('option').remove();

            countries.forEach(c => {
                select.append('option').attr('value', c).text(c);
            });

            // Set default if exists
            if (countries.includes(this.state.currentCountry)) {
                select.property('value', this.state.currentCountry);
            } else {
                this.state.currentCountry = countries[0];
            }
        }

        // --- Core Filter Logic ---
        getFilteredData() {
            return this.data.filter(d =>
                d.EventYear === this.state.currentYear &&
                d.Country1 === this.state.currentCountry &&
                d.EventCount >= this.state.minEvents
            );
        }

        update() {
            const currentData = this.getFilteredData();
            this.drawMap(currentData);
            this.drawRanking(currentData); // New Viz
            this.drawScatter(currentData);
            this.drawTimeline();
        }

        // --- Visualizations ---

        drawMap(data) {
            const container = d3.select('#map');
            container.selectAll('*').remove();

            const {width, height} = container.node().getBoundingClientRect();

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Projection handling
            const projection = d3.geoNaturalEarth1()
                .scale(width / 5.5) // Adjusted scale for container
                .translate([width / 2, height / 1.8]);

            const path = d3.geoPath().projection(projection);

            // Create lookup map
            const valMap = new Map();
            data.forEach(d => valMap.set(d.Country2, d[this.state.currentMetric]));

            const g = svg.append('g');

            g.selectAll('path')
                .data(this.geoData.features)
                .join('path')
                .attr('d', path)
                .attr('fill', d => {
                    if (d.id === this.state.currentCountry) return this.config.colors.selectedStroke;
                    const val = valMap.get(d.id);
                    return val !== undefined ? this.colorScale(val) : '#e2e8f0';
                })
                .attr('stroke', 'white')
                .attr('stroke-width', 0.5)
                .style('cursor', 'pointer')
                .on('mouseover', (e, d) => {
                    const val = valMap.get(d.id);
                    const txt = val !== undefined
                        ? `${d.properties.name}: ${val.toFixed(2)}`
                        : `${d.properties.name}: No Data`;
                    this.showTooltip(e, txt);
                    d3.select(e.target).attr('opacity', 0.8);
                })
                .on('mouseout', (e) => {
                    this.hideTooltip();
                    d3.select(e.target).attr('opacity', 1);
                })
                .on('click', (e, d) => {
                    // Update global state on click
                    this.state.currentCountry = d.id;
                    d3.select('#countrySelect').property('value', d.id);
                    this.update();
                });
        }

        // NEW: Top & Bottom Relations Bar Chart
        drawRanking(data) {
            const container = d3.select('#ranking');
            container.selectAll('*').remove();

            if (data.length === 0) return this.showNoData(container);

            const {width, height} = container.node().getBoundingClientRect();
            const margin = {top: 30, right: 30, bottom: 20, left: 50};
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Sort data desc
            const sorted = [...data].sort((a, b) => b[this.state.currentMetric] - a[this.state.currentMetric]);

            // Get top 5 and bottom 5
            const top5 = sorted.slice(0, 5);
            const bottom5 = sorted.slice(-5).reverse(); // Reverse to stack from center outwards if needed, or just list

            // Combine with a spacer if needed, but simple list is better for vertical space
            // Let's just show top 5 positive and top 5 negative (bottom of list)
            const combined = [...top5, ...bottom5];

            const y = d3.scaleBand()
                .range([0, chartHeight])
                .domain(combined.map(d => d.Country2))
                .padding(0.2);

            // X scale needs to handle negative and positive
            const x = d3.scaleLinear()
                .domain([-10, 10])
                .range([0, chartWidth]);

            // Grid line at 0
            svg.append('line')
                .attr('x1', x(0))
                .attr('x2', x(0))
                .attr('y1', 0)
                .attr('y2', chartHeight)
                .attr('stroke', '#ccc')
                .attr('stroke-dasharray', '3,3');

            // Bars
            svg.selectAll('rect')
                .data(combined)
                .join('rect')
                .attr('x', d => x(Math.min(0, d[this.state.currentMetric])))
                .attr('y', d => y(d.Country2))
                .attr('width', d => Math.abs(x(d[this.state.currentMetric]) - x(0)))
                .attr('height', y.bandwidth())
                .attr('fill', d => this.colorScale(d[this.state.currentMetric]))
                .attr('rx', 3)
                .on('mouseover', (e, d) => this.showTooltip(e, `${d.Country2}: ${d[this.state.currentMetric].toFixed(2)}`))
                .on('mouseout', () => this.hideTooltip());

            // Y Axis (Country Codes)
            svg.append('g')
                .call(d3.axisLeft(y).tickSize(0))
                .select('.domain').remove();

            // Add labels inside or next to bars for better readability
            svg.selectAll('.bar-label')
                .data(combined)
                .join('text')
                .attr('class', 'bar-label')
                .attr('x', d => d[this.state.currentMetric] < 0 ? x(0) + 5 : x(0) - 5)
                .attr('y', d => y(d.Country2) + y.bandwidth() / 2 + 4)
                .attr('text-anchor', d => d[this.state.currentMetric] < 0 ? 'start' : 'end')
                .text(d => d.Country2)
                .style('font-size', '10px')
                .style('fill', '#666');
        }

        drawScatter(data) {
            const container = d3.select('#scatter');
            container.selectAll('*').remove();

            if (data.length === 0) return this.showNoData(container);

            const {width, height} = container.node().getBoundingClientRect();
            const margin = this.config.margins;
            const innerW = width - margin.left - margin.right;
            const innerH = height - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const x = d3.scaleLinear()
                .domain([-10, 10])
                .range([0, innerW]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.EventCount)]).nice()
                .range([innerH, 0]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${innerH})`)
                .call(d3.axisBottom(x));

            svg.append('g').call(d3.axisLeft(y).ticks(5).tickFormat(d3.format('.2s')));

            // Dots
            svg.append('g')
                .selectAll('circle')
                .data(data)
                .join('circle')
                .attr('cx', d => x(d.AvgTone)) // Always use Tone for X in this chart? Or Current Metric?
                .attr('cy', d => y(d.EventCount))
                .attr('r', 5)
                .attr('fill', d => this.colorScale(d[this.state.currentMetric]))
                .attr('fill-opacity', 0.7)
                .attr('stroke', '#fff')
                .on('mouseover', (e, d) => {
                    this.showTooltip(e, `<b>${d.Country2}</b><br>Tone: ${d.AvgTone}<br>Events: ${d.EventCount}`);
                    d3.select(e.target).attr('r', 8).attr('fill-opacity', 1);
                })
                .on('mouseout', (e) => {
                    this.hideTooltip();
                    d3.select(e.target).attr('r', 5).attr('fill-opacity', 0.7);
                });

            // Labels
            svg.append('text')
                .attr('x', innerW / 2)
                .attr('y', innerH + 35)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('fill', '#666')
                .text('Average Tone');
        }

        drawTimeline() {
            const container = d3.select('#timeline');
            container.selectAll('*').remove();

            const {width, height} = container.node().getBoundingClientRect();
            const margin = this.config.margins;
            const innerW = width - margin.left - margin.right;
            const innerH = height - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Aggregate data over all years for selected country
            const historyData = this.data.filter(d =>
                d.Country1 === this.state.currentCountry &&
                d.EventCount >= this.state.minEvents
            );

            // Group by year and get mean
            const rolled = d3.rollup(historyData,
                v => d3.mean(v, d => d[this.state.currentMetric]),
                d => d.EventYear
            );

            const lineData = Array.from(rolled, ([year, val]) => ({year, val}))
                .sort((a, b) => a.year - b.year);

            if (lineData.length === 0) return this.showNoData(container);

            // Scales
            const x = d3.scaleLinear()
                .domain(d3.extent(lineData, d => d.year))
                .range([0, innerW]);

            const y = d3.scaleLinear()
                .domain([-10, 10])
                .range([innerH, 0]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${innerH})`)
                .call(d3.axisBottom(x).tickFormat(d3.format('d')));

            svg.append('g').call(d3.axisLeft(y));

            // Line
            const line = d3.line()
                .x(d => x(d.year))
                .y(d => y(d.val))
                .curve(d3.curveMonotoneX);

            svg.append('path')
                .datum(lineData)
                .attr('fill', 'none')
                .attr('stroke', this.config.colors.highlight)
                .attr('stroke-width', 2)
                .attr('d', line);

            // Dots
            svg.selectAll('.dot')
                .data(lineData)
                .join('circle')
                .attr('cx', d => x(d.year))
                .attr('cy', d => y(d.val))
                .attr('r', 4)
                .attr('fill', 'white')
                .attr('stroke', this.config.colors.highlight)
                .attr('stroke-width', 2)
                .on('mouseover', (e, d) => this.showTooltip(e, `Year: ${d.year}<br>Val: ${d.val.toFixed(2)}`))
                .on('mouseout', () => this.hideTooltip());

            // Zero Line
            svg.append('line')
                .attr('x1', 0).attr('x2', innerW)
                .attr('y1', y(0)).attr('y2', y(0))
                .attr('stroke', '#ccc')
                .attr('stroke-dasharray', '4,4');
        }

        // --- Helpers ---

        showNoData(container) {
            container.append('div')
                .style('height', '100%')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('justify-content', 'center')
                .style('color', '#999')
                .text('No data available for current selection');
        }

        showTooltip(e, html) {
            const tooltip = d3.select('#tooltip');
            tooltip.html(html)
                .style('opacity', 1)
                .style('left', (e.pageX + 15) + 'px')
                .style('top', (e.pageY - 10) + 'px');
        }

        hideTooltip() {
            d3.select('#tooltip').style('opacity', 0);
        }
    }

    // Initialize
    const app = new Dashboard();
    app.init();

</script>
</body>
</html>